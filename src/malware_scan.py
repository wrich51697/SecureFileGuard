# malware_scan.py
# Author: William Richmond
# Date: 2024-11-17
# Class: CYBR-260-45
# Assignment: Final Project
# Description: Provides functions for scanning files for malware using ClamAV and VirusTotal.
# Revised on: 2024-11-21

import pyclamd
import logging
import os
import hashlib
import uuid
import requests

# VirusTotal API Key (Ensure this is stored securely in production)
VIRUSTOTAL_API_KEY = os.getenv("VIRUSTOTAL_API_KEY", "your_api_key_here")
VIRUSTOTAL_API_URL = "https://www.virustotal.com/api/v3/files"

# Ensure the logs directory exists
log_directory = 'logs'
if not os.path.exists(log_directory):
    os.makedirs(log_directory)

# Configure logging
logging.basicConfig(
    filename=os.path.join(log_directory, 'malware_scan.log'),
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)

# Function: connect_to_clamav
# Purpose: Establishes a connection to the ClamAV daemon.
# Inputs: None
# Returns: ClamdAgnostic object if successful, None if connection fails.
def connect_to_clamav():
    try:
        cd = pyclamd.ClamdAgnostic()
        if cd.ping():
            logging.info("Connected to ClamAV daemon successfully.")
            return cd
        else:
            logging.error("Failed to ping ClamAV daemon.")
            return None
    except Exception as e:
        logging.error(f"Error connecting to ClamAV daemon: {e}")
        return None

# Function: hash_file
# Purpose: Computes the SHA256 hash of a file.
# Inputs: file_path (str)
# Returns: str - The computed hash or None if an error occurs.
def hash_file(file_path: str) -> str:
    sha256_hash = hashlib.sha256()
    try:
        with open(file_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    except Exception as e:
        logging.error(f"Error hashing file {file_path}: {e}")
        return None

# Function: scan_with_virustotal
# Purpose: Scans a file hash with VirusTotal.
# Inputs: file_hash (str)
# Returns: dict - Scan results with status and threat details.
def scan_with_virustotal(file_hash: str) -> dict:
    if file_hash in hash_cache:
        logging.info(f"Skipping VirusTotal scan for cached hash: {file_hash}")
        return {"status": "clean", "threat": None}

    headers = {"x-apikey": VIRUSTOTAL_API_KEY}
    response = requests.get(f"{VIRUSTOTAL_API_URL}/{file_hash}", headers=headers)

    if response.status_code == 200:
        data = response.json()
        positives = data.get("data", {}).get("attributes", {}).get("last_analysis_stats", {}).get("malicious", 0)
        if positives > 0:
            logging.warning(f"VirusTotal detected threats for hash {file_hash}. Malicious count: {positives}")
            return {"status": "infected", "threat": f"{positives} threats detected by VirusTotal"}
        else:
            logging.info(f"VirusTotal scan for hash {file_hash} is clean.")
            hash_cache.add(file_hash)
            return {"status": "clean", "threat": None}
    else:
        logging.error(f"VirusTotal API error: {response.status_code} - {response.text}")
        return {"status": "error", "threat": "VirusTotal scan failed"}

# Function: scan_file
# Purpose: Scans a file for malware using ClamAV and VirusTotal.
# Inputs: file_path (str)
# Returns: dict - Scan results including status and threats if found.
def scan_file(file_path: str) -> dict:
    scan_id = str(uuid.uuid4())
    logging.info(f"Starting scan with ID: {scan_id} for file: {file_path}")

    scan_results = {
        "file": file_path,
        "status": "unknown",
        "threat": None
    }

    if not os.path.isfile(file_path):
        logging.error(f"File not found: {file_path}")
        scan_results["status"] = "error"
        scan_results["threat"] = "File not found"
        return scan_results

    # ClamAV Scan
    cd = connect_to_clamav()
    if cd:
        try:
            result = cd.scan_file(file_path)
            if result is None:
                scan_results["status"] = "clean"
            else:
                scan_results["status"] = "infected"
                scan_results["threat"] = list(result.values())[0]
                logging.warning(f"ClamAV detected malware: {scan_results['threat']}")
        except Exception as e:
            logging.error(f"Error during ClamAV scan: {e}")
            scan_results["status"] = "error"
            scan_results["threat"] = str(e)
            return scan_results
    else:
        scan_results["status"] = "error"
        scan_results["threat"] = "ClamAV connection failed"
        return scan_results

    # VirusTotal Scan for additional checks (if ClamAV result is clean)
    if scan_results["status"] == "clean":
        file_hash = hash_file(file_path)
        if file_hash:
            vt_results = scan_with_virustotal(file_hash)
            if vt_results["status"] == "infected":
                scan_results.update(vt_results)
                logging.warning(f"VirusTotal detected malware: {scan_results['threat']}")

    logging.info(f"Final scan results for {file_path}: {scan_results}")
    return scan_results

# Function: log_scan_results
# Purpose: Logs the scan results.
# Inputs: file_path (str), scan_results (dict)
# Returns: None
def log_scan_results(file_path: str, scan_results: dict):
    log_message = f"File: {file_path}, Status: {scan_results['status']}, Threat: {scan_results['threat']}"
    if scan_results["status"] == "infected":
        logging.warning(log_message)
    else:
        logging.info(log_message)

# Function: quarantine_file
# Purpose: Moves infected files to a quarantine directory.
# Inputs: file_path (str), quarantine_dir (str)
# Returns: None
def quarantine_file(file_path: str, quarantine_dir="quarantine"):
    if not os.path.exists(quarantine_dir):
        os.makedirs(quarantine_dir)
    try:
        quarantine_path = os.path.join(quarantine_dir, os.path.basename(file_path))
        os.rename(file_path, quarantine_path)
        logging.info(f"File {file_path} moved to quarantine: {quarantine_path}")
    except Exception as e:
        logging.error(f"Failed to quarantine file {file_path}: {e}")
