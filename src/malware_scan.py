# malware_scan.py
# Author: William Richmond
# Date: 2024-11-17
# Class: CYBR-260-45
# Assignment: Final Project
# Description: Provides functions for scanning files for malware using ClamAV and VirusTotal.
# Revised on: 2024-12-07

import ctypes
import hashlib
import os
import subprocess
import sys
import time
import pyclamd

from src.logger_config import LoggerConfig

# Initialize logger for this module
logger = LoggerConfig(name="malware_scan", log_filename="malware_scan.log").get_logger()


# Constants
VIRUSTOTAL_API_KEY = os.getenv("VIRUSTOTAL_API_KEY", "your_api_key_here")
VIRUSTOTAL_API_URL = "https://www.virustotal.com/api/v3/files"


class MalwareScanner:
    """
    Encapsulates functionality for scanning files with ClamAV and VirusTotal.
    """

    # Function: elevate_privileges
    # Purpose: Re-run the script with administrative privileges if not elevated.
    # Inputs: None
    # Returns: None
    @staticmethod
    def elevate_privileges():
        """Ensure the script is running as an administrator."""
        if not ctypes.windll.shell32.IsUserAnAdmin():
            logger.info("Attempting to elevate privileges...")
            ctypes.windll.shell32.ShellExecuteW(
                None, "runas", sys.executable, " ".join(sys.argv), None, 1
            )
            sys.exit()

    # Function: start_clamav
    # Purpose: Starts the ClamAV daemon (clamd) if it is not already running.
    # Inputs: None
    # Returns: None
    @staticmethod
    def start_clamav():
        """Start ClamAV daemon with elevated privileges if required."""
        try:
            # Ensure the script is running with admin privileges
            MalwareScanner.elevate_privileges()

            # Check if clamd is already running
            import psutil
            for process in psutil.process_iter(attrs=["name"]):
                if "clamd" in process.info["name"]:
                    logger.info("ClamAV daemon is already running.")
                    return

            # Start the ClamAV daemon
            logger.info("Starting ClamAV daemon...")
            subprocess.Popen(
                ["C:\\Program Files\\ClamAV\\clamd.exe"],
                stdout=subprocess.DEVNULL,
                stderr=subprocess.DEVNULL
            )

            # Wait until ClamAV is ready
            for _ in range(10):  # Retry for up to 100 seconds
                try:
                    cd = pyclamd.ClamdAgnostic()
                    if cd.ping():
                        logger.info("ClamAV daemon started successfully.")
                        return
                except Exception:
                    time.sleep(10)

            logger.error("Failed to start ClamAV daemon: Timed out.")
            raise RuntimeError("Failed to start ClamAV daemon: Timed out.")
        except Exception as e:
            logger.error(f"Failed to start ClamAV daemon: {e}")
            raise

    # (Remaining methods are unchanged and preserved as they were.)

    # Function: __init__
    # Purpose: Initializes the MalwareScanner class.
    # Inputs: clamav_retries (int) - Number of retries for ClamAV connection.
    #         retry_delay (int) - Delay between retries in seconds.
    # Returns: None
    def __init__(self, clamav_retries=5, retry_delay=2):
        self.clamav_retries = clamav_retries
        self.retry_delay = retry_delay

    # Function: connect_to_clamav
    # Purpose: Establishes a connection to the ClamAV daemon.
    # Inputs: None
    # Returns: ClamdAgnostic object if successful, None otherwise.
    def connect_to_clamav(self):
        for attempt in range(self.clamav_retries):
            try:
                cd = pyclamd.ClamdAgnostic()
                if cd.ping():
                    logger.info("Connected to ClamAV daemon successfully.")
                    return cd
            except Exception as e:
                logger.error(f"Error connecting to ClamAV daemon on attempt {attempt + 1}: {e}")
            time.sleep(self.retry_delay)
        logger.error("Failed to connect to ClamAV daemon after multiple attempts.")
        return None

    # Function: hash_file
    # Purpose: Computes the SHA256 hash of a file.
    # Inputs: file_path (str) - Path to the file to hash.
    # Returns: str - The computed hash, or raises ValueError if an error occurs.
    @staticmethod
    def hash_file(file_path: str) -> str:
        """Compute SHA256 hash of a given file."""
        sha256_hash = hashlib.sha256()
        try:
            with open(file_path, "rb") as f:
                for byte_block in iter(lambda: f.read(4096), b""):
                    sha256_hash.update(byte_block)
            return sha256_hash.hexdigest()
        except Exception as e:
            normalized_path = os.path.normpath(file_path)
            logger.error(f"Error hashing file {normalized_path}: {e}")
            raise ValueError(f"Failed to compute hash for file: {normalized_path}") from e


# Function: scan_with_clamav
    # Purpose: Scans a file using ClamAV.
    # Inputs: cd (ClamdAgnostic object) - ClamAV client.
    #         file_path (str) - Path to the file to scan.
    # Returns: dict - Scan results containing status and threat details.
    @staticmethod
    def scan_with_clamav(cd, file_path: str) -> dict:
        """Perform a ClamAV scan on the specified file."""
        try:
            # Ensure the file path is absolute
            file_path = os.path.abspath(file_path)
            normalized_path = os.path.normpath(file_path)
            logger.debug(f"Scanning file at absolute path: {normalized_path}")

# Check if the file exists before scanning
            if not os.path.exists(file_path):
                normalized_path = os.path.normpath(file_path)
                logger.error(f"File does not exist: {normalized_path}")
                return {"status": "error", "threat": "File path check failure: No such file or directory."}

            # Perform the ClamAV scan
            result = cd.scan_file(file_path)
            if result is None:
                normalized_path = os.path.normpath(file_path)
                logger.info(f"File scanned clean: {normalized_path}")
                return {"status": "clean", "threat": None}
            else:
                normalized_path = os.path.normpath(file_path)
                logger.warning(f"Suspicious file detected: {normalized_path}, Threat: {list(result.values())[0]}")
                return {"status": "suspicious", "threat": list(result.values())[0]}

        except Exception as e:
            normalized_path = os.path.normpath(file_path)
            logger.error(f"Error during ClamAV scan for {normalized_path}: {e}")
            return {"status": "error", "threat": str(e)}

    # Function: scan_file
    # Purpose: Scans a file for malware using ClamAV and optionally VirusTotal.
    # Inputs: file_path (str) - Path to the file to scan.
    # Returns: dict - Scan results containing status and threat details.
    def scan_file(self, file_path: str) -> dict:
        """Scan a file for malware using ClamAV."""
        normalized_path = os.path.normpath(file_path)
        logger.info(f"Starting malware scan for file: {normalized_path}")

        if not os.path.isfile(file_path):
            normalized_path = os.path.normpath(file_path)
            logger.error(f"File not found: {normalized_path}")
            return {"status": "error", "threat": "File not found"}

        cd = self.connect_to_clamav()
        if not cd:
            return {"status": "error", "threat": "ClamAV connection failed"}

        clamav_results = self.scan_with_clamav(cd, file_path)
        return clamav_results


# Main entry point
if __name__ == "__main__":
    # Ensure elevated privileges
    MalwareScanner.elevate_privileges()

    # Ensure ClamAV is running
    MalwareScanner.start_clamav()

    logger = LoggerConfig("malware_scan", "malware_scan.log").get_logger()
    logger.info("Test log entry for malware_scan.py")
